# Spaceship Bridge Scene — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace Screen 1 (Pikachu) with an animated pixel-art spaceship bridge — static 466×466 background + 4 character sprites + console blink, each animated by independent LVGL timers.

**Architecture:** Background is a host-side generated pixel array (build.rs → `OUT_DIR/spaceship_bg.rs`) to avoid Rust's slow const-eval for 217K pixels. Character sprites use `const fn` pixel math (small enough). All are LVGL `lv_img` widgets layered over each other. Three `lv_timer` callbacks cycle crew, commander, and console blink independently.

**Tech Stack:** Rust embedded (ESP32-S3), LVGL 8.x via lvgl-sys, LV_COLOR_16_SWAP=1 (all RGB565 values byte-swapped at definition time), `build.rs` for background codegen.

**Design doc:** `docs/plans/2026-02-21-spaceship-scene-design.md`

---

## Color Reference (byte-swapped RGB565 for LV_COLOR_16_SWAP=1)

```
BG_DARK     = 0x0819  // #1a2040 — dark navy floor
WALL        = 0xAC29  // #2a3460 — back wall / side walls
CONSOLE     = 0x6719  // #1c2e3a — console panel body
SCREEN_BLU  = 0x5F06  // #00c8ff — monitor glow (cyan)
SCREEN_GRN  = 0xF107  // #00ff88 — readout panel (green)
WARN_RED    = 0x00F9  // #ff2200 — blink state / warning
METAL       = 0x1453  // #5060a0 — metal trim / structural
STAR_WHT    = 0xFFFF  // #ffffff — stars in windows
SKIN        = 0xD7FE  // #f0c888 — crew skin tone (approx)
UNIFORM     = 0xAC29  // same as WALL — dark navy suit
```

To verify a color value: `rgb565(r,g,b) = ((r>>3)<<11)|((g>>2)<<5)|(b>>3)`, then swap = `(val>>8)|(val<<8)`.

---

## Layout Reference (466×466 display, circular radius 233)

```
y=0   ┌──────────────────────────────────────────────────┐
      │ [STAR WIN]   [BACK CONSOLE  x:150..316]  [STAR WIN] │  back wall (y<150)
      │              [crew#3 sprite]                         │
y=150 ├──────────────────────────────────────────────────┤
      │ [L-CONSOLE]                       [R-CONSOLE]    │
      │  x:15..165                         x:301..451    │
      │  [crew#1]                           [crew#2]     │  floor (y≥145)
      │                                                  │
      │               FLOOR PANEL GRID                   │
      │                                                  │
      │          [COMMANDER CONSOLE x:130..336]          │
y=466 └──────────────────────────────────────────────────┘
                       [commander sprite]
```

---

## Task 1: Create `src/spaceship.rs` skeleton + wire into `main.rs`

**Files:**
- Create: `src/spaceship.rs`
- Modify: `src/main.rs` (add `mod spaceship;`)

**Step 1: Create the module skeleton**

Create `src/spaceship.rs` with this exact content:

```rust
// src/spaceship.rs
// Spaceship bridge scene pixel art.
// Background is code-generated (see build.rs → OUT_DIR/spaceship_bg.rs).
// Character sprites use const fn pixel math.

// ─── Background (466×466, generated by build.rs) ─────────────────────────────
include!(concat!(env!("OUT_DIR"), "/spaceship_bg.rs"));

// ─── Sprite dimensions ───────────────────────────────────────────────────────
pub const CREW_W: i32 = 32;
pub const CREW_H: i32 = 64;
pub const CMD_W:  i32 = 40;
pub const CMD_H:  i32 = 72;
pub const BLINK_W: i32 = 20;
pub const BLINK_H: i32 = 10;

// ─── Color constants (byte-swapped RGB565, LV_COLOR_16_SWAP=1) ──────────────
const BG_DARK:    u16 = 0x0819;
const CONSOLE:    u16 = 0x6719;
const SCREEN_BLU: u16 = 0x5F06;
const SCREEN_GRN: u16 = 0xF107;
const WARN_RED:   u16 = 0x00F9;
const METAL:      u16 = 0x1453;
const SKIN:       u16 = 0xD7FE;
const UNIFORM:    u16 = 0xAC29;
const WALL:       u16 = 0xAC29;

// ─── Utility ─────────────────────────────────────────────────────────────────
const fn in_rect(x: i32, y: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {
    x >= x1 && x <= x2 && y >= y1 && y <= y2
}

const fn in_ellipse(x: i32, y: i32, cx: i32, cy: i32, a: i32, b: i32) -> bool {
    let dx = x - cx;
    let dy = y - cy;
    dx * dx * b * b + dy * dy * a * a <= a * a * b * b
}

// ─── Crew sprites (32×64) ────────────────────────────────────────────────────
// Placeholder: all CONSOLE color — replace in Task 3
const fn pixel_crew_a(_x: i32, _y: i32) -> u16 { CONSOLE }
const fn pixel_crew_b(_x: i32, _y: i32) -> u16 { CONSOLE }

// ─── Commander sprites (40×72) ───────────────────────────────────────────────
// Placeholder: all CONSOLE color — replace in Task 4
const fn pixel_cmd_a(_x: i32, _y: i32) -> u16 { BG_DARK }
const fn pixel_cmd_b(_x: i32, _y: i32) -> u16 { BG_DARK }
const fn pixel_cmd_c(_x: i32, _y: i32) -> u16 { BG_DARK }

// ─── Console blink sprites (20×10) ───────────────────────────────────────────
const fn pixel_blink_a(_x: i32, _y: i32) -> u16 { SCREEN_BLU }
const fn pixel_blink_b(_x: i32, _y: i32) -> u16 { SCREEN_GRN }

// ─── Frame generators ────────────────────────────────────────────────────────
const fn make_crew_frame_a() -> [u16; (CREW_W * CREW_H) as usize] {
    let mut p = [BG_DARK; (CREW_W * CREW_H) as usize];
    let mut y = 0i32;
    while y < CREW_H { let mut x = 0i32; while x < CREW_W {
        p[(y * CREW_W + x) as usize] = pixel_crew_a(x, y);
        x += 1; } y += 1; }
    p
}
const fn make_crew_frame_b() -> [u16; (CREW_W * CREW_H) as usize] {
    let mut p = [BG_DARK; (CREW_W * CREW_H) as usize];
    let mut y = 0i32;
    while y < CREW_H { let mut x = 0i32; while x < CREW_W {
        p[(y * CREW_W + x) as usize] = pixel_crew_b(x, y);
        x += 1; } y += 1; }
    p
}
const fn make_cmd_frame(f: u8) -> [u16; (CMD_W * CMD_H) as usize] {
    let mut p = [BG_DARK; (CMD_W * CMD_H) as usize];
    let mut y = 0i32;
    while y < CMD_H { let mut x = 0i32; while x < CMD_W {
        p[(y * CMD_W + x) as usize] = match f {
            0 => pixel_cmd_a(x, y),
            1 => pixel_cmd_b(x, y),
            _ => pixel_cmd_c(x, y),
        };
        x += 1; } y += 1; }
    p
}
const fn make_blink_frame(f: u8) -> [u16; (BLINK_W * BLINK_H) as usize] {
    let mut p = [SCREEN_BLU; (BLINK_W * BLINK_H) as usize];
    let mut y = 0i32;
    while y < BLINK_H { let mut x = 0i32; while x < BLINK_W {
        p[(y * BLINK_W + x) as usize] = if f == 0 { pixel_blink_a(x, y) } else { pixel_blink_b(x, y) };
        x += 1; } y += 1; }
    p
}

pub static CREW_FRAME_A: [u16; (CREW_W * CREW_H) as usize] = make_crew_frame_a();
pub static CREW_FRAME_B: [u16; (CREW_W * CREW_H) as usize] = make_crew_frame_b();
pub static CMD_FRAME_A:  [u16; (CMD_W * CMD_H) as usize]  = make_cmd_frame(0);
pub static CMD_FRAME_B:  [u16; (CMD_W * CMD_H) as usize]  = make_cmd_frame(1);
pub static CMD_FRAME_C:  [u16; (CMD_W * CMD_H) as usize]  = make_cmd_frame(2);
pub static BLINK_FRAME_A: [u16; (BLINK_W * BLINK_H) as usize] = make_blink_frame(0);
pub static BLINK_FRAME_B: [u16; (BLINK_W * BLINK_H) as usize] = make_blink_frame(1);
```

**Step 2: Add `mod spaceship;` to `main.rs`**

In `src/main.rs`, find the module declarations at the top and add:

```rust
mod spaceship;
```

**Step 3: Verify it compiles (build.rs hasn't generated spaceship_bg.rs yet, so this will fail — that's expected)**

Run: `cargo build 2>&1 | head -30`
Expected: compile error mentioning `spaceship_bg.rs` not found via include! — confirms module wiring works.

---

## Task 2: Generate background pixel array via `build.rs`

**Files:**
- Modify: `build.rs`

**Step 1: Read the existing build.rs**

Current content is just:
```rust
fn main() {
    embuild::espidf::sysenv::output();
}
```

**Step 2: Rewrite `build.rs` to add background generation**

```rust
use std::io::Write;

fn rgb565_swap(r: u8, g: u8, b: u8) -> u16 {
    let r5 = (r >> 3) as u16;
    let g6 = (g >> 2) as u16;
    let b5 = (b >> 3) as u16;
    let rgb = (r5 << 11) | (g6 << 5) | b5;
    (rgb >> 8) | (rgb << 8) // byte-swap for LV_COLOR_16_SWAP=1
}

fn pixel_bg(x: i32, y: i32) -> u16 {
    let bg_dark    = rgb565_swap(0x1a, 0x20, 0x40); // dark navy floor
    let wall       = rgb565_swap(0x2a, 0x34, 0x60); // back/side walls
    let console    = rgb565_swap(0x1c, 0x2e, 0x3a); // console panel body
    let screen_blu = rgb565_swap(0x00, 0xc8, 0xff); // monitor cyan
    let screen_grn = rgb565_swap(0x00, 0xff, 0x88); // readout green
    let metal      = rgb565_swap(0x50, 0x60, 0xa0); // metal trim
    let star_wht   = rgb565_swap(0xff, 0xff, 0xff); // stars

    // ── Regions ──────────────────────────────────────────────────────────────
    let in_back_wall = y < 150;

    // Windows (upper-left and upper-right)
    let in_left_win  = x >= 20  && x <= 140 && y >= 10 && y <= 145;
    let in_right_win = x >= 326 && x <= 446 && y >= 10 && y <= 145;
    let in_window = in_left_win || in_right_win;

    // Stars: deterministic scatter using hash
    let is_star = in_window && ((x * 7 + y * 13 + x * y / 3) % 31 == 0);

    // Window inner border (1-2px dark frame)
    let on_win_border = in_window && (
        x == 20 || x == 140 || x == 326 || x == 446 ||
        y == 10 || y == 145
    );

    // ── Back-center console: x 150..316, y 15..120 ────────────────────────
    let in_back_con  = x >= 150 && x <= 316 && y >= 15 && y <= 120;
    let in_back_scr  = x >= 183 && x <= 283 && y >= 30 && y <= 95; // cyan screen
    let on_back_con_border = in_back_con && !in_back_scr && (
        x == 150 || x == 316 || y == 15 || y == 120 ||
        x == 151 || x == 315 || y == 16 || y == 119
    );

    // Side console readouts inside back console (green strips)
    let in_back_grn_l = x >= 155 && x <= 178 && y >= 30 && y <= 95;
    let in_back_grn_r = x >= 288 && x <= 311 && y >= 30 && y <= 95;

    // ── Left console: x 15..165, y 195..295 ───────────────────────────────
    let in_left_con  = x >= 15  && x <= 165 && y >= 195 && y <= 295;
    let in_left_scr  = x >= 40  && x <= 140 && y >= 210 && y <= 270;
    let on_left_con_border = in_left_con && !in_left_scr && (
        x == 15 || x == 165 || y == 195 || y == 295 ||
        x == 16 || x == 164 || y == 196 || y == 294
    );
    let in_left_grn  = x >= 145 && x <= 162 && y >= 210 && y <= 270;

    // ── Right console: x 301..451, y 195..295 ─────────────────────────────
    let in_right_con  = x >= 301 && x <= 451 && y >= 195 && y <= 295;
    let in_right_scr  = x >= 326 && x <= 426 && y >= 210 && y <= 270;
    let on_right_con_border = in_right_con && !in_right_scr && (
        x == 301 || x == 451 || y == 195 || y == 295 ||
        x == 302 || x == 450 || y == 196 || y == 294
    );
    let in_right_grn  = x >= 304 && x <= 321 && y >= 210 && y <= 270;

    // ── Commander console: x 130..336, y 370..445 ─────────────────────────
    let in_cmd_con   = x >= 130 && x <= 336 && y >= 370 && y <= 445;
    let in_cmd_scr   = x >= 163 && x <= 303 && y >= 385 && y <= 430;
    let on_cmd_con_border = in_cmd_con && !in_cmd_scr && (
        x == 130 || x == 336 || y == 370 || y == 445 ||
        x == 131 || x == 335 || y == 371 || y == 444
    );
    let in_cmd_grn_l = x >= 135 && x <= 158 && y >= 385 && y <= 430;
    let in_cmd_grn_r = x >= 308 && x <= 331 && y >= 385 && y <= 430;

    // ── Floor panel grid (subtle lines) ───────────────────────────────────
    let on_floor_grid = y >= 145 && !in_left_con && !in_right_con && !in_cmd_con
        && (x % 46 == 0 || y % 46 == 0);

    // ── Rendering (priority: front features first) ─────────────────────────
    if in_back_scr   { screen_blu }
    else if in_back_grn_l || in_back_grn_r { screen_grn }
    else if on_back_con_border { metal }
    else if in_back_con { console }

    else if in_left_scr  { screen_blu }
    else if in_left_grn  { screen_grn }
    else if on_left_con_border  { metal }
    else if in_left_con  { console }

    else if in_right_scr { screen_blu }
    else if in_right_grn { screen_grn }
    else if on_right_con_border { metal }
    else if in_right_con { console }

    else if in_cmd_scr   { screen_blu }
    else if in_cmd_grn_l || in_cmd_grn_r { screen_grn }
    else if on_cmd_con_border  { metal }
    else if in_cmd_con   { console }

    else if is_star        { star_wht }
    else if on_win_border  { metal }
    else if in_window      { bg_dark } // dark space through windows

    else if on_floor_grid  { wall }   // subtle grid lines
    else if in_back_wall   { wall }   // back wall darker than floor
    else { bg_dark }                  // floor
}

fn generate_spaceship_bg() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = std::path::Path::new(&out_dir).join("spaceship_bg.rs");
    let mut f = std::fs::File::create(&dest).unwrap();

    let w = 466i32;
    let h = 466i32;
    let n = (w * h) as usize;

    writeln!(f, "pub static BG_FRAME: [u16; {n}] = [").unwrap();
    for y in 0..h {
        for x in 0..w {
            write!(f, "{},", pixel_bg(x, y)).unwrap();
        }
    }
    writeln!(f, "];").unwrap();
}

fn main() {
    embuild::espidf::sysenv::output();
    generate_spaceship_bg();
}
```

**Step 3: Build and verify background generation**

Run: `cargo build 2>&1 | tail -20`
Expected: compiles successfully. The `include!()` in `spaceship.rs` will pull in `BG_FRAME`.

If you see "cannot find value `BG_FRAME`" — double-check the `include!()` path in `spaceship.rs` matches what `generate_spaceship_bg()` writes to.

**Step 4: Commit**

```bash
git add build.rs src/spaceship.rs src/main.rs
git commit -m "feat: spaceship module skeleton + background codegen"
```

---

## Task 3: Crew sprite pixel art (3 crew × 2 frames)

**Files:**
- Modify: `src/spaceship.rs`

The 3 crew members share the same pixel art body (top-down view of seated figure). Each has 2 frames: idle posture (frame A) and slight lean forward / typing (frame B).

Sprite is 32×64 (width×height). The crew figure occupies roughly the lower 40px (y=24..64); upper 24px are "transparency" filled with whatever floor/console color is behind them. Since we don't have alpha, choose the background color of the figure's station:
- Crew sitting over a console → use `CONSOLE` as bg fill color
- Actually: use `BG_DARK` for simplicity (set lv_img widget bg to transparent by overlapping with background image — just pick the color they appear over)

**Step 1: Replace placeholder crew pixel functions in `src/spaceship.rs`**

Replace the placeholder `pixel_crew_a` and `pixel_crew_b` with:

```rust
// Top-down seated crew figure, 32×64 sprite.
// Figure occupies y=20..64. y=0..19 is background fill (CONSOLE color so it
// blends with the console panel they're seated at).
// Frame A: upright at console. Frame B: leaned 1px forward (head at y+1).
const fn crew_pixel(x: i32, y: i32, lean: bool) -> u16 {
    let offset = if lean { 1 } else { 0 };

    // Chair/seat area (very bottom, y=55..63)
    let in_chair = in_rect(x, y, 8, 55, 23, 63);

    // Torso/body (y=34+offset..54)
    let in_body = in_rect(x, y, 6, 34 + offset, 25, 54);

    // Shoulders — wider than body (y=33+offset..36+offset)
    let in_shoulders = in_rect(x, y, 4, 33 + offset, 27, 36 + offset);

    // Head — 8×8 ellipse centered at (15, 26+offset)
    let in_head = in_ellipse(x, y, 15, 26 + offset, 4, 4);

    // Hair — top 2 rows of head (dark)
    let in_hair = in_ellipse(x, y, 15, 24 + offset, 4, 2);

    // Face detail — tiny eyes at y=26+offset, x=12..13 and x=16..17
    let in_eyes = y == 26 + offset && (
        (x == 12 || x == 13) || (x == 16 || x == 17)
    );

    // Console fill above figure
    let in_bg = y < 20;

    if in_bg           { CONSOLE }
    else if in_head    { if in_hair { UNIFORM } else if in_eyes { 0x0000u16 } else { SKIN } }
    else if in_shoulders || in_body { UNIFORM }
    else if in_chair   { METAL }
    else               { CONSOLE }
}

const fn pixel_crew_a(x: i32, y: i32) -> u16 { crew_pixel(x, y, false) }
const fn pixel_crew_b(x: i32, y: i32) -> u16 { crew_pixel(x, y, true) }
```

**Step 2: Build to verify pixel functions compile**

Run: `cargo build 2>&1 | tail -10`
Expected: success.

**Step 3: Commit**

```bash
git add src/spaceship.rs
git commit -m "feat: crew sprite pixel art (2 frames, shared geometry)"
```

---

## Task 4: Commander sprite pixel art (3 frames)

**Files:**
- Modify: `src/spaceship.rs`

Commander is 40×72, standing full-height (not seated). Three frames:
- Frame A: standing straight, arms at sides
- Frame B: pointing left (right arm extends to x=2..10)
- Frame C: pointing right (left arm extends to x=29..37)

Distinctive: orange/gold command stripe on uniform (left chest stripe).

```rust
// Standing commander figure, 40×72 sprite, top-down slightly angled.
// Figure centered horizontally; y=0..71 active.
// BG_DARK fill for transparent areas.
const fn cmd_pixel(x: i32, y: i32, frame: u8) -> u16 {
    let gold: u16 = rgb565_const(0xff, 0xc0, 0x00); // gold command stripe

    // Head — ellipse centered at (20, 10), rx=6, ry=6
    let in_head = in_ellipse(x, y, 20, 10, 6, 6);
    let in_hair = in_ellipse(x, y, 20, 7, 6, 3);
    let in_eyes = y == 11 && ((x == 17 || x == 18) || (x == 22 || x == 23));

    // Shoulders — rect x=8..31, y=18..22
    let in_shoulders = in_rect(x, y, 8, 18, 31, 22);

    // Torso — rect x=11..28, y=22..50
    let in_torso = in_rect(x, y, 11, 22, 28, 50);

    // Command stripe (gold, left chest) — x=11..14, y=24..40
    let in_stripe = in_rect(x, y, 11, 24, 14, 40);

    // Legs — two columns: x=12..18 and x=21..27, y=51..68
    let in_legs = (in_rect(x, y, 12, 51, 18, 68) || in_rect(x, y, 21, 51, 27, 68));

    // Feet (darker) — y=69..71
    let in_feet = y >= 69 && (in_rect(x, y, 11, 69, 18, 71) || in_rect(x, y, 21, 69, 27, 71));

    // Arms: frame-dependent
    // Frame A — arms at sides: x=8..10 and x=29..31, y=22..45
    let in_arm_l_a = in_rect(x, y, 8, 22, 10, 45);
    let in_arm_r_a = in_rect(x, y, 29, 22, 31, 45);
    // Frame B — pointing left: left arm extends further left (x=1..10, y=28..31)
    let in_arm_l_b = in_rect(x, y, 1, 28, 10, 31);
    let in_arm_r_b = in_arm_r_a;
    // Frame C — pointing right: right arm extends further right (x=29..38, y=28..31)
    let in_arm_l_c = in_arm_l_a;
    let in_arm_r_c = in_rect(x, y, 29, 28, 38, 31);

    let in_arm_l = match frame { 0 => in_arm_l_a, 1 => in_arm_l_b, _ => in_arm_l_c };
    let in_arm_r = match frame { 0 => in_arm_r_a, 1 => in_arm_r_b, _ => in_arm_r_c };

    if in_head {
        if in_hair { UNIFORM }
        else if in_eyes { 0x0000 }
        else { SKIN }
    } else if in_torso || in_shoulders || in_arm_l || in_arm_r {
        if in_stripe { gold } else { UNIFORM }
    } else if in_legs {
        UNIFORM
    } else if in_feet {
        METAL
    } else {
        BG_DARK
    }
}

// rgb565_swap is not const fn (uses closures), so inline the formula:
const fn rgb565_const(r: u8, g: u8, b: u8) -> u16 {
    let r5 = (r >> 3) as u16;
    let g6 = (g >> 2) as u16;
    let b5 = (b >> 3) as u16;
    let rgb = (r5 << 11) | (g6 << 5) | b5;
    (rgb >> 8) | (rgb << 8)
}

const fn pixel_cmd_a(x: i32, y: i32) -> u16 { cmd_pixel(x, y, 0) }
const fn pixel_cmd_b(x: i32, y: i32) -> u16 { cmd_pixel(x, y, 1) }
const fn pixel_cmd_c(x: i32, y: i32) -> u16 { cmd_pixel(x, y, 2) }
```

Also update `SKIN` constant at the top of `spaceship.rs` using `rgb565_const`:
```rust
const SKIN: u16 = rgb565_const(0xf0, 0xc8, 0x88);
```

**Step 2: Build**

Run: `cargo build 2>&1 | tail -10`
Expected: success.

**Step 3: Commit**

```bash
git add src/spaceship.rs
git commit -m "feat: commander sprite pixel art (3 frames with gold command stripe)"
```

---

## Task 5: Console blink sprite (2 frames)

**Files:**
- Modify: `src/spaceship.rs`

Small 20×10 sprite overlaid on the back-center console's main screen area. Frame A = cyan (normal), frame B = green (blink state). This simulates a pulsing readout.

The placeholders already work correctly. Verify they look right by confirming:
```rust
const fn pixel_blink_a(_x: i32, _y: i32) -> u16 { SCREEN_BLU }
const fn pixel_blink_b(_x: i32, _y: i32) -> u16 { SCREEN_GRN }
```

These are already correct from Task 1. No changes needed.

**Verify build:**
Run: `cargo build 2>&1 | tail -5`

---

## Task 6: Replace Pikachu scene with spaceship scene in `main.rs`

**Files:**
- Modify: `src/main.rs`

**Step 1: Remove Pikachu statics**

Delete these lines from the statics section:

```rust
static mut IMG_WIDGET: *mut lvgl_sys::lv_obj_t = core::ptr::null_mut();
static mut FRAME_IDX: u8 = 0;
static mut IMG_A_DSC: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut IMG_B_DSC: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
```

**Step 2: Add spaceship animation statics**

Add these statics (after SCREEN2):

```rust
// Spaceship animation state — single-thread, written once during init
static mut CREW_WIDGETS: [*mut lvgl_sys::lv_obj_t; 3] = [core::ptr::null_mut(); 3];
static mut CMD_WIDGET: *mut lvgl_sys::lv_obj_t = core::ptr::null_mut();
static mut BLINK_WIDGET: *mut lvgl_sys::lv_obj_t = core::ptr::null_mut();

static mut CREW_FRAME: u8 = 0;
static mut CMD_FRAME: u8 = 0;
static mut BLINK_FRAME: u8 = 0;

// Image descriptors — must be 'static (LVGL holds raw pointers)
static mut CREW_DSC_A: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut CREW_DSC_B: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut CMD_DSC_A:  *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut CMD_DSC_B:  *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut CMD_DSC_C:  *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut BLINK_DSC_A: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut BLINK_DSC_B: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
static mut BG_DSC: *const lvgl_sys::lv_img_dsc_t = core::ptr::null();
```

**Step 3: Remove `anim_timer_cb` and `make_img_dsc` functions**

Delete the old `anim_timer_cb` and `make_img_dsc` functions entirely.

**Step 4: Add new helper and timer callbacks**

Add after the `gesture_cb` function:

```rust
/// Build an lv_img_dsc_t for a u16 RGB565 pixel array.
/// w, h: sprite dimensions in pixels.
fn make_dsc(pixels: &'static [u16], w: u32, h: u32) -> lvgl_sys::lv_img_dsc_t {
    let mut dsc = lvgl_sys::lv_img_dsc_t::default();
    dsc.header.set_cf(lvgl_sys::LV_IMG_CF_TRUE_COLOR as u32);
    dsc.header.set_w(w);
    dsc.header.set_h(h);
    dsc.data_size = (w * h * core::mem::size_of::<u16>() as u32) as u32;
    dsc.data = pixels.as_ptr() as *const u8;
    dsc
}

/// Crew animation timer — fires every 600 ms, cycles through 2 frames.
/// All 3 crew widgets share the same sprite frames (same body shape).
unsafe extern "C" fn crew_timer_cb(_timer: *mut lvgl_sys::lv_timer_t) {
    CREW_FRAME = 1 - CREW_FRAME;
    let src = if CREW_FRAME == 0 { CREW_DSC_A } else { CREW_DSC_B };
    for i in 0..3 {
        lvgl_sys::lv_img_set_src(CREW_WIDGETS[i], src as *const _);
    }
}

/// Commander animation timer — fires every 800 ms, cycles A→B→C→A.
unsafe extern "C" fn cmd_timer_cb(_timer: *mut lvgl_sys::lv_timer_t) {
    CMD_FRAME = (CMD_FRAME + 1) % 3;
    let src = match CMD_FRAME {
        0 => CMD_DSC_A,
        1 => CMD_DSC_B,
        _ => CMD_DSC_C,
    };
    lvgl_sys::lv_img_set_src(CMD_WIDGET, src as *const _);
}

/// Console blink timer — fires every 1200 ms, toggles between two colors.
unsafe extern "C" fn blink_timer_cb(_timer: *mut lvgl_sys::lv_timer_t) {
    BLINK_FRAME = 1 - BLINK_FRAME;
    let src = if BLINK_FRAME == 0 { BLINK_DSC_A } else { BLINK_DSC_B };
    lvgl_sys::lv_img_set_src(BLINK_WIDGET, src as *const _);
}
```

**Step 5: Replace Screen 1 Pikachu init block with spaceship init**

Find the `// ── Screen 1: Pokemon sprite scene ───` comment and everything until `// Screen 2:`. Replace with:

```rust
// ── Screen 1: Spaceship bridge scene ─────────────────────────────────────

// Black base background for the screen
lvgl_sys::lv_obj_set_style_bg_color(
    SCREEN1,
    lvgl_sys::_LV_COLOR_MAKE(0x1a, 0x20, 0x40),
    lvgl_sys::LV_STATE_DEFAULT,
);

// ── Background image (466×466) ────────────────────────────────────────────
let bg_dsc = Box::leak(Box::new(make_dsc(
    &spaceship::BG_FRAME,
    466,
    466,
)));
BG_DSC = bg_dsc as *const _;
let bg_img = lvgl_sys::lv_img_create(SCREEN1);
lvgl_sys::lv_img_set_src(bg_img, bg_dsc as *mut lvgl_sys::lv_img_dsc_t as *const _);
lvgl_sys::lv_obj_set_pos(bg_img, 0, 0);

// ── Crew descriptors (shared frames for all 3 crew) ───────────────────────
let crew_a_dsc = Box::leak(Box::new(make_dsc(
    &spaceship::CREW_FRAME_A,
    spaceship::CREW_W as u32,
    spaceship::CREW_H as u32,
)));
let crew_b_dsc = Box::leak(Box::new(make_dsc(
    &spaceship::CREW_FRAME_B,
    spaceship::CREW_W as u32,
    spaceship::CREW_H as u32,
)));
CREW_DSC_A = crew_a_dsc as *const _;
CREW_DSC_B = crew_b_dsc as *const _;

// ── Crew widgets: (x, y) top-left of sprite ───────────────────────────────
// Positions relative to background image (absolute display coords).
// Crew #3 (top-center): center sprite at (233, 158)
// Crew #1 (left):       center sprite at ( 90, 240)
// Crew #2 (right):      center sprite at (376, 240)
let crew_positions: [(i32, i32); 3] = [
    (233 - spaceship::CREW_W / 2, 158 - spaceship::CREW_H / 2), // crew #3 top-center
    ( 90 - spaceship::CREW_W / 2, 240 - spaceship::CREW_H / 2), // crew #1 left
    (376 - spaceship::CREW_W / 2, 240 - spaceship::CREW_H / 2), // crew #2 right
];
for i in 0..3 {
    let w = lvgl_sys::lv_img_create(SCREEN1);
    lvgl_sys::lv_img_set_src(w, crew_a_dsc as *mut lvgl_sys::lv_img_dsc_t as *const _);
    lvgl_sys::lv_obj_set_pos(w, crew_positions[i].0, crew_positions[i].1);
    CREW_WIDGETS[i] = w;
}

// ── Commander descriptor and widget ──────────────────────────────────────
let cmd_a_dsc = Box::leak(Box::new(make_dsc(&spaceship::CMD_FRAME_A, spaceship::CMD_W as u32, spaceship::CMD_H as u32)));
let cmd_b_dsc = Box::leak(Box::new(make_dsc(&spaceship::CMD_FRAME_B, spaceship::CMD_W as u32, spaceship::CMD_H as u32)));
let cmd_c_dsc = Box::leak(Box::new(make_dsc(&spaceship::CMD_FRAME_C, spaceship::CMD_W as u32, spaceship::CMD_H as u32)));
CMD_DSC_A = cmd_a_dsc as *const _;
CMD_DSC_B = cmd_b_dsc as *const _;
CMD_DSC_C = cmd_c_dsc as *const _;

// Commander center at (233, 390); sprite top-left:
let cmd_widget = lvgl_sys::lv_img_create(SCREEN1);
lvgl_sys::lv_img_set_src(cmd_widget, cmd_a_dsc as *mut lvgl_sys::lv_img_dsc_t as *const _);
lvgl_sys::lv_obj_set_pos(cmd_widget,
    233 - spaceship::CMD_W / 2,
    390 - spaceship::CMD_H / 2,
);
CMD_WIDGET = cmd_widget;

// ── Console blink widget ──────────────────────────────────────────────────
let blink_a_dsc = Box::leak(Box::new(make_dsc(&spaceship::BLINK_FRAME_A, spaceship::BLINK_W as u32, spaceship::BLINK_H as u32)));
let blink_b_dsc = Box::leak(Box::new(make_dsc(&spaceship::BLINK_FRAME_B, spaceship::BLINK_W as u32, spaceship::BLINK_H as u32)));
BLINK_DSC_A = blink_a_dsc as *const _;
BLINK_DSC_B = blink_b_dsc as *const _;

// Position inside the back-center console screen area (x:183..283, y:30..95)
// Blink widget at (193, 35) — 20×10 overlay
let blink_widget = lvgl_sys::lv_img_create(SCREEN1);
lvgl_sys::lv_img_set_src(blink_widget, blink_a_dsc as *mut lvgl_sys::lv_img_dsc_t as *const _);
lvgl_sys::lv_obj_set_pos(blink_widget, 193, 35);
BLINK_WIDGET = blink_widget;

// ── Animation timers ──────────────────────────────────────────────────────
lvgl_sys::lv_timer_create(Some(crew_timer_cb),  600,  core::ptr::null_mut());
lvgl_sys::lv_timer_create(Some(cmd_timer_cb),   800,  core::ptr::null_mut());
lvgl_sys::lv_timer_create(Some(blink_timer_cb), 1200, core::ptr::null_mut());
```

**Step 6: Build**

Run: `cargo build 2>&1 | tail -20`
Expected: success. Fix any borrow/lifetime errors — the most common issue is `make_dsc` expecting `&'static [u16]`; ensure all sprite statics are `pub static` (not `const`).

**Step 7: Commit**

```bash
git add src/main.rs
git commit -m "feat: wire spaceship scene into Screen 1 (background + 4 sprites + 3 timers)"
```

---

## Task 7: Flash and visual verification

**Step 1: Flash to device**

Run:
```bash
cargo espflash flash --monitor
```

If `--monitor` exits early (non-interactive terminal), flash first then monitor separately:
```bash
cargo espflash flash
cargo espflash monitor
```

**Step 2: Check serial log**

Expected output:
```
=== LVGL display test ===
FT3168 touch controller ready
lcd_driver_init OK
LVGL display registered
LVGL touch input registered
Two screens created, gesture callbacks attached
Entering LVGL loop
```

No panics or errors.

**Step 3: Visual verification checklist**

- [ ] Screen 1 shows the spaceship bridge room (dark navy, console panels, star windows)
- [ ] Left window (upper-left) and right window (upper-right) show small white star dots
- [ ] Back-center console (top of screen) is visible with cyan screen
- [ ] Left and right consoles visible with cyan screens
- [ ] Commander console visible at bottom
- [ ] Crew #3 figure visible above back-center console
- [ ] Crew #1 visible over left console area
- [ ] Crew #2 visible over right console area
- [ ] Commander figure visible at bottom-center
- [ ] Crew sprites animate (subtle change every 600ms)
- [ ] Commander sprite animates through 3 poses every 800ms
- [ ] Blink overlay pulses between cyan and green every 1200ms
- [ ] Swipe left to Screen 2 still works (gesture navigation intact)

**Step 4: Adjust sprite positions if needed**

If characters appear at wrong positions, edit `crew_positions` and the commander/blink widget positions in `main.rs`. Each `lv_obj_set_pos(widget, x, y)` sets the top-left corner. Adjust and reflash.

**Step 5: Commit final**

```bash
git add -p  # stage any position adjustments
git commit -m "feat: spaceship bridge scene complete on Screen 1"
```

---

## Pixel Art Tuning Notes

After flashing, if the art needs refinement:

**Background adjustments** (edit `build.rs` `pixel_bg()`):
- Window size/position: adjust `in_left_win` / `in_right_win` bounds
- Console panel sizes: adjust region bounds in pixel_bg
- Star density: change the `% 31` modulus (higher = fewer stars)
- Floor grid: change `% 46` (higher = fewer, wider grid)

**Character adjustments** (edit `src/spaceship.rs`):
- Crew size: adjust rect bounds in `crew_pixel()`
- Commander arm reach: adjust arm rect bounds in `cmd_pixel()`
- Skin/uniform colors: adjust `SKIN` and `UNIFORM` constants

After any build.rs change, the generated file is rebuilt automatically on next `cargo build`.

---

## Flash Usage Summary

| Asset | Size |
|---|---|
| Background (BG_FRAME) | ~424 KB |
| Crew frames (A+B) | ~32 KB |
| Commander frames (A+B+C) | ~17 KB |
| Blink frames (A+B) | < 1 KB |
| **Total added** | **~473 KB** |
