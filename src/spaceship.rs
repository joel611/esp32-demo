// src/spaceship.rs
// Spaceship bridge scene pixel art.
// Background is code-generated (see build.rs → OUT_DIR/spaceship_bg.rs).
// Character sprites use const fn pixel math.

// ─── Background (466×466, generated by build.rs) ─────────────────────────────
include!(concat!(env!("OUT_DIR"), "/spaceship_bg.rs"));

// ─── Sprite dimensions ───────────────────────────────────────────────────────
pub const CREW_W: i32 = 48;
pub const CREW_H: i32 = 64;
pub const CMD_W:  i32 = 56;
pub const CMD_H:  i32 = 80;
pub const BLINK_W: i32 = 20;
pub const BLINK_H: i32 = 10;

// ─── Color constants (byte-swapped RGB565, LV_COLOR_16_SWAP=1) ──────────────
const BG_DARK:    u16 = 0x0819; // dark navy floor — used as sprite background fill
const SCREEN_BLU: u16 = 0x5F06;
const SCREEN_GRN: u16 = 0xF107;
const UNIFORM_DK: u16 = 0x2121; // deep navy uniform
#[allow(dead_code)]
const UNIFORM_LT: u16 = 0x4229; // lighter uniform detail
const SKIN:       u16 = rgb565_const(0xdf, 0xa6, 0x8d);
const HAIR_BROWN: u16 = 0x2143;
const GOLD_TRIM:  u16 = 0x05E6; // command yellow/gold
const CONSOLE_GY: u16 = 0x9492; // console metal grey

// ─── Utility ─────────────────────────────────────────────────────────────────
const fn in_rect(x: i32, y: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {
    x >= x1 && x <= x2 && y >= y1 && y <= y2
}

const fn in_ellipse(x: i32, y: i32, cx: i32, cy: i32, a: i32, b: i32) -> bool {
    let dx = x - cx;
    let dy = y - cy;
    dx * dx * b * b + dy * dy * a * a <= a * a * b * b
}

// rgb565_swap is not const fn (uses closures), so inline the formula:
const fn rgb565_const(r: u8, g: u8, b: u8) -> u16 {
    let r5 = (r >> 3) as u16;
    let g6 = (g >> 2) as u16;
    let b5 = (b >> 3) as u16;
    let rgb = (r5 << 11) | (g6 << 5) | b5;
    (rgb >> 8) | (rgb << 8)
}

// ─── Crew sprites (48×64) ────────────────────────────────────────────────────
// Top-down view of back-of-head and shoulders; crew face away toward consoles.
// Transparent areas filled with BG_DARK (matches dark floor/wall background).
const fn crew_pixel(x: i32, y: i32) -> u16 {
    let in_shoulders = in_rect(x, y, 8, 35, 40, 55);
    let in_neck      = in_rect(x, y, 18, 30, 30, 35);
    let in_head      = in_ellipse(x, y, 24, 25, 10, 10);
    let in_hair      = in_ellipse(x, y, 24, 22, 10, 7);
    let in_chair     = in_rect(x, y, 12, 56, 36, 63);

    if in_hair           { HAIR_BROWN }
    else if in_head      { SKIN }
    else if in_neck      { SKIN }
    else if in_shoulders { UNIFORM_DK }
    else if in_chair     { CONSOLE_GY }
    else                 { BG_DARK }
}

const fn pixel_crew_a(x: i32, y: i32) -> u16 { crew_pixel(x, y) }
const fn pixel_crew_b(x: i32, y: i32) -> u16 { crew_pixel(x, y) }

// ─── Commander sprites (56×80) ───────────────────────────────────────────────
// Front-facing commander with peaked hat, epaulets, and belt.
// Transparent areas filled with BG_DARK. `frame` reserved for future animation.
const fn cmd_pixel(x: i32, y: i32, frame: u8) -> u16 {
    let cx = 28; // horizontal center

    // Hat
    let in_hat_top    = in_rect(x, y, cx - 14, 5, cx + 14, 12);
    let in_hat_brim   = in_rect(x, y, cx - 16, 12, cx + 16, 15);
    let in_hat_emblem = in_rect(x, y, cx - 2, 7, cx + 2, 10);

    // Face
    let in_face = in_ellipse(x, y, cx, 22, 12, 10);
    let in_eyes = y == 23 && (x == cx - 5 || x == cx + 5);

    // Body
    let in_shoulders = in_rect(x, y, cx - 22, 32, cx + 22, 42);
    let in_epaulets  = (x < cx - 18 || x > cx + 18) && in_rect(x, y, 0, 32, 60, 36);
    let in_torso     = in_rect(x, y, cx - 15, 42, cx + 15, 70);
    let in_belt      = in_rect(x, y, cx - 16, 58, cx + 16, 62);

    // Suppress unused frame warning (reserved for future arm-pose animation)
    let _ = frame;

    if in_hat_emblem                         { GOLD_TRIM }
    else if in_hat_top || in_hat_brim        { UNIFORM_DK }
    else if in_eyes                          { BG_DARK }
    else if in_face                          { SKIN }
    else if in_epaulets                      { GOLD_TRIM }
    else if in_belt                          { BG_DARK }
    else if in_shoulders || in_torso         { UNIFORM_DK }
    else                                     { BG_DARK }
}

const fn pixel_cmd_a(x: i32, y: i32) -> u16 { cmd_pixel(x, y, 0) }
const fn pixel_cmd_b(x: i32, y: i32) -> u16 { cmd_pixel(x, y, 1) }
const fn pixel_cmd_c(x: i32, y: i32) -> u16 { cmd_pixel(x, y, 2) }

// ─── Console blink sprites (20×10) ───────────────────────────────────────────
const fn pixel_blink_a(_x: i32, _y: i32) -> u16 { SCREEN_BLU }
const fn pixel_blink_b(_x: i32, _y: i32) -> u16 { SCREEN_GRN }

// ─── Frame generators ────────────────────────────────────────────────────────
const fn make_crew_frame_a() -> [u16; (CREW_W * CREW_H) as usize] {
    let mut p = [BG_DARK; (CREW_W * CREW_H) as usize];
    let mut y = 0i32;
    while y < CREW_H { let mut x = 0i32; while x < CREW_W {
        p[(y * CREW_W + x) as usize] = pixel_crew_a(x, y);
        x += 1; } y += 1; }
    p
}
const fn make_crew_frame_b() -> [u16; (CREW_W * CREW_H) as usize] {
    let mut p = [BG_DARK; (CREW_W * CREW_H) as usize];
    let mut y = 0i32;
    while y < CREW_H { let mut x = 0i32; while x < CREW_W {
        p[(y * CREW_W + x) as usize] = pixel_crew_b(x, y);
        x += 1; } y += 1; }
    p
}
const fn make_cmd_frame(f: u8) -> [u16; (CMD_W * CMD_H) as usize] {
    let mut p = [BG_DARK; (CMD_W * CMD_H) as usize];
    let mut y = 0i32;
    while y < CMD_H { let mut x = 0i32; while x < CMD_W {
        p[(y * CMD_W + x) as usize] = match f {
            0 => pixel_cmd_a(x, y),
            1 => pixel_cmd_b(x, y),
            _ => pixel_cmd_c(x, y),
        };
        x += 1; } y += 1; }
    p
}
const fn make_blink_frame(f: u8) -> [u16; (BLINK_W * BLINK_H) as usize] {
    let mut p = [SCREEN_BLU; (BLINK_W * BLINK_H) as usize];
    let mut y = 0i32;
    while y < BLINK_H { let mut x = 0i32; while x < BLINK_W {
        p[(y * BLINK_W + x) as usize] = if f == 0 { pixel_blink_a(x, y) } else { pixel_blink_b(x, y) };
        x += 1; } y += 1; }
    p
}

pub static CREW_FRAME_A: [u16; (CREW_W * CREW_H) as usize] = make_crew_frame_a();
pub static CREW_FRAME_B: [u16; (CREW_W * CREW_H) as usize] = make_crew_frame_b();
pub static CMD_FRAME_A:  [u16; (CMD_W * CMD_H) as usize]  = make_cmd_frame(0);
pub static CMD_FRAME_B:  [u16; (CMD_W * CMD_H) as usize]  = make_cmd_frame(1);
pub static CMD_FRAME_C:  [u16; (CMD_W * CMD_H) as usize]  = make_cmd_frame(2);
pub static BLINK_FRAME_A: [u16; (BLINK_W * BLINK_H) as usize] = make_blink_frame(0);
pub static BLINK_FRAME_B: [u16; (BLINK_W * BLINK_H) as usize] = make_blink_frame(1);
